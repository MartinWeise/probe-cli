# OONI Probe CLI v3.0.0

| Author       | Simone Basso |
|--------------|--------------|
| Last-Updated | 2019-10-14   |
| Status       | open         |

## Introduction

This document describes the design of v3.0.0 of the OONI
Probe CLI (command line interface). The fundamental design
choice is that the CLI is a tool that other programs can
call. For this reason, the CLI contain subcommands allowing
another program to initiate any user-facing action meaningful
in the OONIverse. In this vein, there is thus a flag for
forcing the CLI to emit output in JSONL format (i.e. a JSON
document on every line). The main use case for this functionality
is to control the command line from the OONI Desktop app.

## Background

The [legacy OONI Probe CLI](https://github.com/ooni/probe-legacy)
is a Python program that exposes a web user interface. This design
has served us well for years, however, it is significantly less
user friendly than the mobile apps. Therefore, it complicates life
for Windows and macOS users that are not developers and want to
use OONI. Hence, the choice of providing [a more user friendly app
for such users, OONI Probe Desktop](
https://github.com/ooni/probe-desktop). We are building this app for
Windows, macOS and Linux using Electron. We are aiming to provide
the same user experience of the mobile apps to desktop users.

The initial design was to link our C++ measurement library,
[Measurement Kit](https://github.com/measurement-kit/measurement-kit),
aka MK, directly into the Electron app. Then, after some iterations,
we have chosen a significantly more modular approach. The desktop app's
main concern is to provide a pleasant UI. The CLI's main concern is
to perform measurements and allow to see measurement results. This
design choice was originally documented in the [Writing a modern
cross-platform desktop app](
https://ooni.org/post/writing-a-modern-cross-platform-desktop-app/)
blog post published on the OONI website.

This document exists to document the functionality that the OONI
Probe CLI should expose to a controlling app, including the required
command line switches and the expected data format.

## Non goals

The main, initial design and implementation goal is to serve the
needs of the desktop app. This document currently does not address
the use cases of running OONI on Linux as a daemon. A future
version of this document is expected to address this limitation
and extend the interfaces defined here to cover such use case.

(If you have ideas on how that could be done, please contribute, to
this document explaining the use cases and proposing a specific
CLI addressing such use cases!)

## Terminology

An _experiment_ is a specific OONI experiment as codified in
the https://github.com/ooni/spec repository. For historical reasons
experiments are also called _tests_ or _nettests_.

Users run _groups of experiments_. For example,`"im"` (short for Instant
Messaging), is the group of all OONI experiments that measure the
blocking of Instant Messagging apps.

A group of experiments produces a _result_.

Every result contains one or more _measurements_. The websites
group produce a measurement for every URL that was tested. All the
other groups produce a measurement for every experiment within
the group itself. For example, the performance group currently is
producing two measurements by default, generated by the NDT and
DASH experiments.

## Use cases

We address two use cases: supporting the desktop app and running
the CLI as an interactive tool.

### Supporting the desktop app

Because we want the desktop app to provide the same user experience
of the mobile app, we need this functionality:

1. discover the user IP, country, and network

2. list the results stored on disk

3. delete one or more results

4. run any group of experiments (websites, instant messaging,
performance, middleboxes), or run them all

5. show each individual measurement

6. upload measurements that were not uploaded

To fully support this use case, we need to force the CLI to emit
messages in JSON, which is easily parseable from Electron.

### Interactive command line usage

We also want users to run the CLI interactively. Users must be able
to perform all the batch operations described above from the CLI with
a reasonably pleasant and user friendly output. We will not specify
exactly how this output is going to look like and we may change it
without notice. Users that want to parse OONI output from scripts are
encouraged to use the batch interface.

## Software architecture

The following diagram summarizes the software architecture:

```
+--------------+   calls with flags   +----------+  .---------.
| OONI Desktop | -------------------> | OONI CLI | | local DB |
+--------------+                      +----------+  `---------'
          `--------<--<--<--<-------------'
                   JSONL messages
```

The OONI CLI is a standalone, as static as possible, Go binary
that allows OONI Desktop to perform all the actions defined
above. The desktop app will communicate with the CLI using command
line flags. The OONI CLI will send _on the standard ouput_ a
stream of JSONL messages (i.e. JSON messages each terminated by
a newline). In principle, we could emit any kind of JSON message,
even though in practice, we emit JSON objects in most cases.

The OONI CLI will statically link to Measurement Kit and/or
ooni/probe-engine, and/or any other library required to
perform OONI measurements.

The OONI CLI will be updated by the desktop app.

The OONI CLI will automatically download and store into
a configuration/state directory any resource that it
may require to perform its operations. This directory
is by default `$HOME/.ooni` on all systems; yet, you can
override it using the `OONI_HOME` environment variable.
In the following we will call this directory the OONI home,
state/configuration directory, or, with a stretch of
semantics, `OONI_HOME`.

The OONI CLI keeps a local database inside of its `OONI_HOME`
directory. Such database keeps track of all the
network experiments that have been run. Measurements will
be saved on disk as JSONL files. Again, the location where
measurements are saved is below the `OONI_HOME`.

The OONI CLI is a binary called `ooniprobe[.exe]`.

## Batch command line interface

This section describes the batch command line interface, i.e., the
one that should be used by the desktop app, or by any other tool, to
drive the OONI CLI. These tools SHOULD set the `OONI_HOME`
environment variable to avoid clashing with ordinary CLI usage.

The basic batch usage of the CLI is the following:

```
ooniprobe --batch <command> [arguments]
```

The controlling app SHOULD write the configuration file for the CLI
into the `OONI_HOME` folder, such that it reflects the settings that
have been configured into the controlling app. We will discuss the
configuration file more in detail later.

The `--batch` flag makes the CLI emit JSONL output. As said
above, this shall be emitted on the standard output.

### Structure of most JSON messages

The general design is that most messages look like log messages
where specific information is represented as a JSON object under
the `fields` key. This way, a basic consumer of the output of
OONI CLI can just print the messages. More advanced consumers like
the desktop app will find actionable information in `fields`.

As you will see most JSON messages have this structure:

```JSON
{
  "fields": {
    "type": "engine"
  },
  "level": "info",
  "timestamp": "2019-10-03T16:52:58.966368+02:00",
  "message": "(1) e14.whatsapp.net ipv4: 158.85.233.52"
}
```

where `fields` contains extra fields, `level` is the severity of
the message, `timestamp` is when it was emitted, and `message`
is a user-facing string. The `type` key within `fields` shall be
used by the desktop app to decide how to specifically process a
given JSON message.

The `level` field should be one of `"debug"`, `"error"`, `"info"`.

### OONI desktop requirements

The desktop app MUST inspect all JSON messages and only process the
messages that it knows how to properly handle. In this specification
we will in particular only describe the messages that are mostly
useful to a batch application. More messages may be emitted. When an
emitted message is not described by this specification, it means we
feel free to change it without notice in a future release.

### Getting the CLI version

This command:

```
ooniprobe --batch version
```

prints the version on the standard output as JSON, followed by newline, e.g.:

```JSON
"3.0.0-beta.4"
```

### Automating the onboarding process

The desktop app is supposed to inform users about risks of
running OONI tests. The following command:

```
ooniprobe --batch onboard --yes
```

forces the CLI to perform a batch onboarding process that
otherwise would have asked questions to users.

### Getting the current IP etc

The command

```
ooniprobe --batch geoip
```

emits this output (where JSONs have been formatted for readability, and, as
mentioned above, more message MAY be emitted)

```JSON
{
  "fields": {
    "asn": "AS30722",
    "country_code": "IT",
    "ip": "127.0.0.1",
    "network_name": "Vodafone Italia S.p.A.",
    "type": "table"
  },
  "level": "info",
  "timestamp": "2019-10-03T16:48:11.475014+02:00",
  "message": "Looked up your location"
}
```

where:

- `"asn"` is the probe ASN formatted as `"AS<number>"`, where `"AS0"` is
used when we don't know the ASN.

- `"country_code"` is the probe country code as a two letters identifier, or
`"ZZ"` when the country code is not known.

- `"ip"` is the probe IP address, or `"127.0.0.1"` if not known.

- `"network_name"` is the name of the ASN, or an empty string if not known.

- `"type"` is `"table"` and indicates that this message SHOULD be
rendered to the user as a table.

### Listing all the results

This command:

```
ooniprobe --batch list
```

lists on the standard output all the results.

In its most general form, the output of this command has
the following high level ABNF grammar:

```
       <results> ::= 1*<result-entry> <summary>
  <result-entry> ::= <JSONL>
       <summary> ::= <JSONL>
```

That is, one or more results entry, followed by a summary. Every
results entry and the summary are JSONL messages.

Specifically, a `<result-entry>` is like:

```JSON
{
  "fields": {
    "type":"result_item",
    "id": 2,
    "is_done": true,
    "name": "websites",

    "asn": 30722,
    "network_country_code": "IT",
    "network_name": "Vodafone Italia S.p.A.",
    "data_usage_down": 2297.6103515625,
    "data_usage_up": 11.1669921875,
    "start_time": "2019-10-03T07:57:41.170538Z",
    "runtime": 0.17,

    "measurement_anomaly_count": 0,
    "measurement_count": 10,

    "test_keys": "{}"
  },
  "level": "info",
  "timestamp": "2019-10-03T16:25:25.39541+02:00",
  "message": "result item"
}
```

where:

- `type` uniquely identifies this entry as a `"result_item"`.

- `id` is the unique identifier of this result.

- `is_done` indicates whether this measurement is complete. Apps SHOULD be
prepared to handle (or ignore) incomplete results.

- `name` is the name of the test group that produced this result.

- `asn`, `network_country_code`, `network_name` have the same semantics
described previously.

- `data_usage_down` and `data_usage_up` are the approximate number of KiB
received and sent to produce this result.

- `start_time` and `runtime` are when we started running this test group
and the number of seconds it took us to do so.

- `measurement_count` and `measurement_anomaly_count` count respectively the
total number of measurements in this result and the number of such measurements
that are anomalies.

- `test_keys` is a set of keys that we may want to show to the user at this
level of abstraction (this is a result dependent serialised JSON).

More specifically, the `test_keys` field will be empty for all experiments
groups but `"performance"`, where it will be like:

```JSON
{
  "upload": 21125.226149733466,
  "download": 76153.12071218148,
  "ping": 64,
  "median_bitrate": 36724
}
```

where:

- `"upload"` is the upload speed in kbit/s as measured by the NDT
experiment.

- `"download"` is the download speed in kbit/s as measured by the
NDT experiment.

- `"ping"` is the round-trip time in ms as measured by the NDT
experiment.

- `"median_bitrate"` is the median bitrate in kbit/s as measured by
the DASH experiment.

In case you configure the CLI to only run NDT, you would only get the
NDT generated keys here. Likewise for DASH.

The `<summary>` message, instead, is like:

```JSON
{
  "fields": {
    "total_data_usage_down": 223370.43359375,
    "total_data_usage_up": 24432.0224609375,
    "total_networks": 1,
    "total_tests": 5,
    "type": "result_summary"
  },
  "level": "info",
  "timestamp": "2019-10-03T16:25:25.397729+02:00",
  "message": "result summary"
}
```

with `total_data_usage_down` and `total_data_usage_up` summarising the amount
of KiBs used to produce this result; `total_networks` summarising the number of
ASNs from which we have measurements in this result; `total_tests` being the
number of results that we printed details of; `type` being the key identifying
this entry as a `"result_summary"`.

The `id` field of a `<result-entry>` is key to further drill down the results
using the `ooniprobe --batch list <id>` command, as described below.

### Listing measurements within a result

This command:

```
ooniprobe --batch list <id>
```

provides further information on the measurement within a
specific result entry's `<id>`.

In its most general form, the output of this command has
the following high level ABNF grammar:

```
     <measurements> ::= 1*<measurement-entry> <summary>
<measurement-entry> ::= <JSONL>
          <summary> ::= <JSONL>
```

That is, one or more measurement-entry JSON messages followed
by a summary JSONL message.

Specifically, `<measurement-entry>` is like:

```JSON
{
  "fields": {
    "type": "measurement_item",
    "id": 125,

    "asn": 30722,
    "network_country_code": "IT",
    "network_name": "Vodafone Italia S.p.A.",
    "runtime": 0.317749,
    "start_time": "2019-10-03T07:59:10.325979Z",

    "test_group_name": "im",

    "is_anomaly": false,
    "is_done": true,
    "is_failed": false,
    "failure_msg": "",
    "is_upload_failed": false,
    "is_uploaded": true,
    "upload_failure_msg": "",
    "test_keys": "{}",
    "test_name": "facebook_messenger",

    "url": "",
    "url_category_code": "",
    "url_country_code": ""
  },
  "level": "info",
  "timestamp": "2019-10-03T16:42:00.221666+02:00",
  "message": "measurement"
}
```

where:

- `type` identifies this message as a measurement item.

- `id` is the ID that allows you to retrieve the JSON file produced by
this measurement using `ooniprobe --batch show <id>`.

- `asn`, `network_country_code`, `network_name`, `runtime` and
`start_time` have the semantics described before.

- `test_group_name` is the name of the test group to which this
specific measurement belongs.

- `is_anomaly` indicates whether this measurement contains an anomaly, i.e.,
whether it may be worth further looking into it for signs of censorship.

- `is_done` indicates whether this measurement is complete.

- `is_failed` and `failure_msg` indicate whether and how the measurement failed.

- `is_uploaded`, `is_upload_failed`, and `upload_failure_msg` indicate whether
the measurement is uploaded, and whether and how the upload failed.

- `test_keys` contains some interesting test keys that we may want to show
to the user without pulling the full measurement JSON. This is an experiment
specific serialized JSON. See below for what to expect for each experiment.

- `test_name` is the name of the specific experiment (OONI experiments, aka
nettests, are specified at https://github.com/ooni/spec).

- `url`, `url_category_code`, and `url_country_code` all describe the URL
used by this measurement, if applicable.

The summary message instead is like:

```JSON
{
  "fields": {
    "total_count": 3,
    "anomaly_count": 0,

    "type": "measurement_summary",

    "asn": 30722,
    "data_usage_down": 15.4765625,
    "data_usage_up": 4.556640625,
    "network_country_code": "IT",
    "network_name": "Vodafone Italia S.p.A.",
    "start_time": "2019-10-03T07:59:10.325979Z",
    "total_runtime": 3.141369
  },
  "level": "info",
  "timestamp": "2019-10-03T16:42:00.22201+02:00",
  "message": "measurement summary"
}
```

where:

- `anomaly_count` and `total_count` are the the total number of measurements
emitted and the number of these that were anomalies.

- `type` identifies this as a measurement summary message.

- all other fields have already-described semantics, which in this case of
course is applied to the set of measurements as a whole.

The `id` field of a `<measurement-entry>` message is key to get the
raw measurement JSON, using `ooniprobe --batch show <id>`.

#### Content of the test_keys field

For the `"websites"` experiment group:

```JSON
{
  "accessible": true,
  "blocking": "none"
}
```

where `accessible` indicates whether the URL is accessible and `blocking`
indicates they way in which we believe the URL to be blocked.

For the `"dash"` experiment in the `"performance"` group:

```JSON
{
  "connect_latency": 0.06374096870422363,
  "median_bitrate": 36724, 
  "min_playout_delay": 0
} 
```

where `"connect_latency"` is the time to establish a connection,
`"median_bitrate"` is the median bitrate in kbit/s, and
`"min_playout_delay`" is the minimum delay required to perform
a smooth streaming, given the streaming speed.

For the `"ndt"` experiment in the `"performance"` group:

```JSON
{
  "upload": 21125.226149733466,
  "download": 76153.12071218148,
  "ping": 64
}
```

where `"upload"` is the upload speed in kbit/s, `"download"` is the
download speed in kbit/s, and `"ping"` is the minimum RTT in ms.

For the experiments in the `"middlebox"` group:

```JSON
{}
```

For the `"facebook_messenger"` experiment in the `"im"` group:

```JSON
{
  "facebook_dns_blocking": false,
  "facebook_tcp_blocking": false
}
```

where `"facebook_dns_blocking"` indicates whether Facebook Messenger
is blocked at the DNS level, and `"facebook_tcp_blocking"` indicates
whether it is blocked at the TCP/IP level.

For the `"telegram"` experiment in the `"im"` group:

```JSON
{
  "telegram_http_blocking": false,
  "telegram_tcp_blocking": false,
  "telegram_web_blocking": false,
}
```

where the keys have the following meaning:

- `"telegram_http_blocking"` indicates whether the connection to some
selected telegram servers is blocked by HTTP blocking, resulting in the
telegram app not being able to work

- `"telegram_tcp_blocking"` indicates whether the connection to some
selected telegram servers is blocked by TCP blocking, resulting in the
telegram app not being able to work

- `"telegram_web_blocking"` indicates instead whether the telegram web
interface is blocked

For the `"whatsapp"` experiment in the `"im"` group:

```JSON
{
  "registration_server_blocking": false,
  "whatsapp_web_blocking": false,
  "whatsapp_endpoints_blocking": false
} 
```

where:

- `"registration_server_blocking"` indicates whether the registration
server is blocked

- `"whatsapp_web_blocking"` indicates whether the web interface
to WhatsApp is blocked

- `"whatsapp_endpoints_blocking"` indciates whether selected endpoints
used by the WhatsApp app are blocked

### Getting a measurement JSON

This command:

```
ooniprobe --batch show <id>
```

emits in output the measurement identified by `<id>`. The data
format is described at https://github.com/ooni/spec.

### Running experiments groups

This command:

```
ooniprobe [-v] --batch run [all|im|middlebox|performance|websites]
```

runs the specified group of nettests, or all if no argument
is specified on the command line. The `-v` flag allows you to
enable verbose logging.

This command will emit two kind of messages. The first kind of
messages consists of messages emitted by the measurement engine;
the second kind consists of progress messages.

Progress messages are like:

```JSON
{
  "fields": {
    "key": "performance.NDT",
    "percentage": 0.7640000000000001,
    "type": "progress"
  },
  "level": "info",
  "timestamp": "2019-10-14T13:14:30.790923+02:00",
  "message": "upload-speed (elapsed 9.55 s) 20996.89 kbit/s (num_streams 1)"
}
```

where `key` identifies the experiment within the scope of the
experiment group, `percentage` is the percentage of completion
of the whole experiment group, and `message` is a message you
may want to show to a user to further qualify what is happening.

More specifically, `key` may be one of:

- `"im.FacebookMessenger"`
- `"im.Telegram"`
- `"im.WhatsApp"`
- `"middlebox.HTTPHeaderFieldManipulation"`
- `"middlebox.HTTPInvalidRequestLine"`
- `"performance.Dash"`
- `"performance.NDT"`
- `"websites.WebConnectivity"`

Measurement engine messages are like:

```JSON
{
  "fields": {
    "type": "engine"
  },
  "level": "info",
  "timestamp": "2019-10-03T16:52:56.327828+02:00",
  "message": "starting facebook_messenger"
}
```

They are warning, informational, or debugging messages emitted by
the measurement engine to describe what it is doing.

### Knowing the location of the home directory

This command:

```
ooniprobe --batch info
```

emits this JSON:

```JSON
{
  "fields": {
    "path": "/home/sbs/.ooni"
  },
  "level": "info",
  "timestamp": "2019-10-14T13:25:35.145144+02:00",
  "message": "Home"
}
```

where `message` is `"Home"` and `fields.path` contains the path to the
currently used OONI's home directory. Of course, the output changes
depending on the configured `OONI_HOME` environment variable value.

## State and configuration directory

This is `$HOME/.ooni` in all systems. The `ooniprobe --batch info`
command can tell you the precise path on your system, subject to the
override caused by the `OONI_HOME` environment variable.

The state and configuration directory contains:

- `assets`: directory where assets like GeoIP files are downloaded

- `config.json`: default config file, used unless you specify
another file using `--config <file>`

- `db`: directory containing the SQLite3 database

- `msmts`: directory containing the JSON measurements

Running concurrent instances of the OONI CLI is unsupported. They
may conflict attempting to download/update assets. This is the main
reason why we recommend using another `OONI_HOME` when running the
CLI from another program/app. We do this when running the CLI from
OONI Desktop, and you should do the same in your use case.

## Configuration file

The configuration file has the following structure:

```JSON
{
  "sharing": {
    "include_ip": false,
    "include_asn": true,
    "include_country": true,
    "upload_results": true
  },
  "test_settings": {
    "websites": {
      "enabled_categories": [],
      "limit": 0
    },
    "instant_messaging": {
      "enabled_tests": [
        "facebook-messenger",
        "whatsapp",
        "telegram"
      ]
    },
    "middlebox": {
      "enabled_tests": [
        "http-invalid-request-line",
        "http-header-field-manipulation"
      ]
    }
  }
}
```

where:

- `sharing` configures what information to include in measurements
and whether to automatically upload measurements

- `test_settings.websites` allows to configure the enabled
categories and how many URLs test at a time (`0` means no limit)

- `test_settings.instant_messaging` configures what experiments
to run when running the `im` group

- `test_settings.middlebox` configures what experiments
to run when running the `middlebox` group
